// test_complete_common_lib.dryad
// Teste completo da common lib Dryad (IO.*, core.*)

println("=== Teste Completo da Common Lib Dryad ===");
println();

// ====== TESTE IO.Console ======
println("1. Testando IO.Console:");
use IO.Console as Console;

let console = new Console();

console.println("- println funcionando");
console.print("- print funcionando");
console.newLine();

// Teste de input/output (comentado para não bloquear testes automatizados)
// let userInput = console.input("Digite algo: ");
// console.println("Você digitou:", userInput);

console.log("- log funcionando");
console.write("- write funcionando");
console.newLine();

try {
    console.clear();
    console.println("- clear executado (pode não ter efeito visível)");
} catch (e) {
    console.println("- clear ainda não implementado:", e);
}

println();

// ====== TESTE IO.FileSystem ======
println("2. Testando IO.FileSystem:");
use IO.FileSystem as FS;

let fs = new FS();
let testFile = "test_temp_file.txt";
let testContent = "Conteúdo de teste da common lib";

try {
    // Teste de escrita
    fs.writeFile(testFile, testContent);
    println("- writeFile: OK");
    
    // Teste de verificação de existência
    if (fs.fileExists(testFile)) {
        println("- fileExists: OK (arquivo criado)");
    } else {
        println("- fileExists: ERRO (arquivo não encontrado)");
    }
    
    // Teste de leitura
    let readContent = fs.readFile(testFile);
    if (readContent == testContent) {
        println("- readFile: OK (conteúdo correto)");
    } else {
        println("- readFile: ERRO (conteúdo incorreto)");
    }
    
    // Teste de append
    let appendText = "\nLinha adicional";
    fs.appendFile(testFile, appendText);
    let newContent = fs.readFile(testFile);
    if (newContent != testContent) {
        println("- appendFile: OK (conteúdo modificado)");
    } else {
        println("- appendFile: ERRO (conteúdo não modificado)");
    }
    
    // Teste de aliases
    let aliasContent = fs.read(testFile);
    fs.write("test_alias.txt", "teste alias");
    if (fs.exists("test_alias.txt")) {
        println("- aliases (read/write/exists): OK");
        fs.delete("test_alias.txt");
    } else {
        println("- aliases: ERRO");
    }
    
    // Limpeza
    fs.deleteFile(testFile);
    if (!fs.fileExists(testFile)) {
        println("- deleteFile: OK (arquivo removido)");
    } else {
        println("- deleteFile: ERRO (arquivo ainda existe)");
    }
    
} catch (e) {
    println("- Erro nos testes de FileSystem:", e);
}

println();

// ====== TESTE IO.Buffer ======
println("3. Testando IO.Buffer:");
use IO.Buffer as Buffer;
use IO.StringBuffer as StringBuffer;

try {
    let buffer = new Buffer();
    buffer.init(100);
    println("- Buffer.init: OK");
    
    let length = buffer.length();
    println("- Buffer.length:", length);
    
    buffer.append("teste");
    println("- Buffer.append: OK");
    
    let str = buffer.toString();
    println("- Buffer.toString:", str);
    
} catch (e) {
    println("- Erro nos testes de Buffer:", e);
}

try {
    let strBuffer = new StringBuffer();
    strBuffer.init();
    println("- StringBuffer.init: OK");
    
    strBuffer.append("Hello");
    strBuffer.append(" World");
    let result = strBuffer.toString();
    println("- StringBuffer resultado:", result);
    
    println("- StringBuffer.length:", strBuffer.length());
    println("- StringBuffer.isEmpty:", strBuffer.isEmpty());
    
    strBuffer.clear();
    println("- StringBuffer após clear, isEmpty:", strBuffer.isEmpty());
    
} catch (e) {
    println("- Erro nos testes de StringBuffer:", e);
}

println();

// ====== TESTE core.Types ======
println("4. Testando core.Types:");
use core.Types as Types;

let types = new Types();

// Valores de teste
let num = 42;
let str = "hello world";
let flag = true;
let nothing = null;

println("- Testando typeof:");
println("  typeof(42):", types.typeof(num));
println("  typeof('hello'):", types.typeof(str));
println("  typeof(true):", types.typeof(flag));
println("  typeof(null):", types.typeof(nothing));

println("- Testando verificações de tipo:");
println("  isNumber(42):", types.isNumber(num));
println("  isString('hello'):", types.isString(str));
println("  isBool(true):", types.isBool(flag));
println("  isNull(null):", types.isNull(nothing));

println("- Testando conversões:");
println("  toString(42):", types.toString(num));
println("  toString(true):", types.toString(flag));
println("  toNumber('123'):", types.toNumber("123"));
println("  toNumber('abc'):", types.toNumber("abc"));
println("  toBool(1):", types.toBool(1));
println("  toBool(0):", types.toBool(0));
println("  toBool(''):", types.toBool(""));

println("- Testando comparações:");
println("  equals(42, 42):", types.equals(42, 42));
println("  equals(42, '42'):", types.equals(42, "42"));

println("- Testando validações:");
println("  isValid(42):", types.isValid(num));
println("  isValid(null):", types.isValid(nothing));
println("  isEmpty(''):", types.isEmpty(""));
println("  isEmpty('hello'):", types.isEmpty("hello"));

// Testando aliases
println("- Testando aliases:");
println("  typeOf(42):", types.typeOf(num));
println("  stringify(true):", types.stringify(flag));
println("  parse('456'):", types.parse("456"));

println();

// ====== TESTE core.Meta ======
println("5. Testando core.Meta:");
use core.Meta as Meta;

let meta = new Meta();

// Testes básicos de reflection
println("- Testando reflection básica:");

// Criar uma classe para testar
class TestClass {
    public field1;
    private field2;
    
    public fun method1() {
        return "method1 result";
    }
    
    public fun method2(param) {
        return "method2: " + param;
    }
}

let testInstance = new TestClass();
testInstance.field1 = "value1";

try {
    let className = meta.getClassName(testInstance);
    println("  getClassName:", className);
} catch (e) {
    println("  getClassName error:", e);
}

try {
    let methods = meta.getClassMethods(testInstance);
    println("  getClassMethods:", methods);
} catch (e) {
    println("  getClassMethods error:", e);
}

try {
    let fields = meta.getClassFields(testInstance);
    println("  getClassFields:", fields);
} catch (e) {
    println("  getClassFields error:", e);
}

try {
    let hasMethod = meta.hasMethod(testInstance, "method1");
    println("  hasMethod('method1'):", hasMethod);
    
    let hasField = meta.hasField(testInstance, "field1");
    println("  hasField('field1'):", hasField);
} catch (e) {
    println("  hasMethod/hasField error:", e);
}

try {
    let fieldValue = meta.getField(testInstance, "field1");
    println("  getField('field1'):", fieldValue);
    
    meta.setField(testInstance, "field1", "new value");
    let newFieldValue = meta.getField(testInstance, "field1");
    println("  getField após setField:", newFieldValue);
} catch (e) {
    println("  getField/setField error:", e);
}

// Testes de módulos
println("- Testando informações de módulos:");
try {
    let modules = meta.getLoadedModules();
    println("  getLoadedModules:", modules);
} catch (e) {
    println("  getLoadedModules error:", e);
}

try {
    let isLoaded = meta.isModuleLoaded("IO");
    println("  isModuleLoaded('IO'):", isLoaded);
} catch (e) {
    println("  isModuleLoaded error:", e);
}

// Testes de ambiente
println("- Testando informações de ambiente:");
try {
    let scope = meta.getCurrentScope();
    println("  getCurrentScope:", scope);
} catch (e) {
    println("  getCurrentScope error:", e);
}

try {
    let globalScope = meta.getGlobalScope();
    println("  getGlobalScope:", globalScope);
} catch (e) {
    println("  getGlobalScope error:", e);
}

// Testes de debugging
println("- Testando debugging:");
try {
    let stackTrace = meta.getStackTrace();
    println("  getStackTrace:", stackTrace);
} catch (e) {
    println("  getStackTrace error:", e);
}

try {
    let memory = meta.getMemoryUsage();
    println("  getMemoryUsage:", memory);
} catch (e) {
    println("  getMemoryUsage error:", e);
}

// Testes de clonagem
println("- Testando clonagem:");
let original = "test string";
try {
    let cloned = meta.cloneObject(original);
    println("  cloneObject:", cloned);
    println("  são iguais:", types.equals(original, cloned));
    
    let deepCloned = meta.deepClone(original);
    println("  deepClone:", deepCloned);
} catch (e) {
    println("  clonagem error:", e);
}

// Testes de aliases
println("- Testando aliases de meta:");
try {
    let reflection = meta.reflect(testInstance);
    println("  reflect result:", reflection);
} catch (e) {
    println("  reflect error:", e);
}

try {
    let introspection = meta.introspect(testInstance);
    println("  introspect result:", introspection);
} catch (e) {
    println("  introspect error:", e);
}

println();

// ====== TESTE DE INTEGRAÇÃO ======
println("6. Teste de Integração:");

// Teste usando múltiplos módulos juntos
let console2 = new Console();
let types2 = new Types();
let meta2 = new Meta();

// Criar dados de teste
let testData = {
    number: 123,
    text: "integration test",
    flag: true,
    empty: null
};

console2.println("- Teste de integração iniciado");

// Usar types para analisar os dados
for (let key in testData) {
    let value = testData[key];
    let type = types2.typeof(value);
    let stringValue = types2.toString(value);
    let isValid = types2.isValid(value);
    
    console2.println("  " + key + ": " + stringValue + " (tipo: " + type + ", válido: " + isValid + ")");
}

// Usar meta para introspecção
try {
    let currentVars = meta2.getAllVariables();
    console2.println("- Variáveis no escopo:", currentVars);
} catch (e) {
    console2.println("- Erro ao obter variáveis:", e);
}

println();
println("=== Teste Completo da Common Lib Finalizado ===");

// ====== RELATÓRIO FINAL ======
println();
println("RELATÓRIO FINAL:");
println("- IO.Console: Funcional (métodos básicos implementados)");
println("- IO.FileSystem: Funcional (operações de arquivo implementadas)"); 
println("- IO.Buffer: Parcialmente implementado (funções básicas)");
println("- core.Types: Funcional (inspeção e conversão de tipos)");
println("- core.Meta: Parcialmente implementado (reflection básica, muitas funções pendentes)");
println("- Integração: Módulos funcionam bem em conjunto");
println();
println("PRÓXIMOS PASSOS:");
println("1. Implementar funções core.Meta restantes (eval, serialize, etc.)");
println("2. Melhorar IO.Buffer com mais funcionalidades");
println("3. Adicionar Directory e Path em IO");
println("4. Implementar tratamento de erros mais robusto");
println("5. Adicionar mais utilitários de debugging e profiling");
