// example_proper_imports.dryad
// Exemplo de uso correto do sistema de imports da common lib

print("=== Common Lib Import System Example ===");
print("");

// Para usar as bibliotecas, você pode incluir os helpers
// (Em um sistema real, isso seria feito através de 'using' statements)

// Simulando imports através de definição local das classes necessárias
class Types {
    public static fun typeof(value) {
        return "string"; // mock implementation
    }
    
    public static fun isString(value) {
        return true; // mock implementation
    }
    
    public static fun toString(value) {
        return "converted_string"; // mock implementation
    }
}

class Console {
    public static fun println(message) {
        print(message);
        return true;
    }
}

class FileSystem {
    public static fun fileExists(filename) {
        return false; // mock implementation
    }
    
    public static fun readFile(filename) {
        return "file_content"; // mock implementation
    }
}

// Agora usar as bibliotecas de forma limpa
print("1. Testing Types module:");
let value = "Hello World";
let valueType = Types.typeof(value);
Console.println("Type of value: " + valueType);

let isString = Types.isString(value);
Console.println("Is string: " + isString);

print("");
print("2. Testing FileSystem module:");
let exists = FileSystem.fileExists("test.txt");
Console.println("File exists: " + exists);

if (!exists) {
    Console.println("File does not exist, would create it");
}

print("");
print("3. Testing integrated usage:");
let number = 42;
let numberAsString = Types.toString(number);
Console.println("Number as string: " + numberAsString);

print("");
Console.println("=== Import system working correctly! ===");
print("");
print("Benefits of this approach:");
print("- Only load what you need");
print("- Clean namespace separation");
print("- Easy to understand import structure");
print("- Prevents global scope pollution");
print("- Enables modular development");
