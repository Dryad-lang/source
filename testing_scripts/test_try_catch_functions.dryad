// test_try_catch_functions.dryad
// Teste try-catch com funções

print("=== TRY-CATCH COM FUNÇÕES ===");

// Função que pode lançar exceção
fun divide(a, b) {
    if (b == 0) {
        throw "Divisão por zero não permitida!";
    }
    return a / b;
}

// Função segura que usa try-catch
fun safeDivide(a, b) {
    try {
        let result = divide(a, b);
        return result;
    } catch (error) {
        print("Erro na divisão:");
        print(error);
        return 0;
    }
}

// Teste 1: Divisão normal
print("1. Divisão normal (10 / 2):");
let result1 = safeDivide(10, 2);
print("Resultado:");
print(result1);

// Teste 2: Divisão por zero
print("2. Divisão por zero (10 / 0):");
let result2 = safeDivide(10, 0);
print("Resultado:");
print(result2);

// Teste 3: Try-catch em nível global
print("3. Try-catch global:");
try {
    let dangerous_result = divide(20, 0);
    print("Nunca deveria chegar aqui");
} catch (global_error) {
    print("Erro capturado globalmente:");
    print(global_error);
}

// Classe com método que pode falhar
class Calculator {
    fun safePower(base, exp) {
        try {
            if (exp < 0) {
                throw "Expoente negativo não suportado";
            }
            
            let result = 1;
            let i = 0;
            while (i < exp) {
                result = result * base;
                i = i + 1;
            }
            return result;
        } catch (power_error) {
            print("Erro no cálculo de potência:");
            print(power_error);
            return -1;
        }
    }
}

print("4. Try-catch em método de classe:");
let calc = Calculator();
let power_result = calc.safePower(2, -3);
print("Resultado da potência:");
print(power_result);

print("=== TRY-CATCH COM FUNÇÕES FUNCIONANDO! ===");
