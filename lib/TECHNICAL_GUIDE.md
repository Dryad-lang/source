# Documenta√ß√£o T√©cnica - Implementa√ß√£o e Resolu√ß√£o de Problemas

Esta documenta√ß√£o t√©cnica detalha como implementar fun√ß√µes nativas, diagnosticar erros e resolver problemas comuns no desenvolvimento das bibliotecas Dryad.

## üìã √çndice

1. [Implementa√ß√£o de Fun√ß√µes Nativas](#implementa√ß√£o-de-fun√ß√µes-nativas)
2. [Sistema de Erros](#sistema-de-erros)
3. [Diagn√≥stico de Problemas](#diagn√≥stico-de-problemas)
4. [Depura√ß√£o Avan√ßada](#depura√ß√£o-avan√ßada)
5. [Padr√µes de Implementa√ß√£o](#padr√µes-de-implementa√ß√£o)
6. [Valida√ß√£o e Testes](#valida√ß√£o-e-testes)

---

## üîß Implementa√ß√£o de Fun√ß√µes Nativas

### Anatomia de uma Fun√ß√£o Nativa

```rust
fn native_exemplo_funcao(args: &[Value]) -> Result<Value, DryadError> {
    // 1. Valida√ß√£o de argumentos
    if args.len() != 2 {
        return Err(DryadError::new(
            "exemplo_funcao: requer exatamente 2 argumentos".to_string(),
            None,
            ErrorSeverity::Error,
        ));
    }

    // 2. Extra√ß√£o e valida√ß√£o de tipos
    let (primeiro, segundo) = match (args.get(0), args.get(1)) {
        (Some(Value::String(s)), Some(Value::Number(n))) => (s, n),
        _ => return Err(DryadError::new(
            "exemplo_funcao: argumentos devem ser (string, number)".to_string(),
            None,
            ErrorSeverity::Error,
        )),
    };

    // 3. L√≥gica da fun√ß√£o
    let resultado = format!("{}: {}", primeiro, n);

    // 4. Retorno
    Ok(Value::String(resultado))
}
```

### Registro de Fun√ß√µes

No arquivo `src/interpreter/native.rs`, adicione ao m√©todo `register_io_functions`:

```rust
fn register_io_functions(&mut self) {
    // ...existing code...
    
    // Nova fun√ß√£o
    self.register("native_exemplo_funcao".to_string(), native_exemplo_funcao);
}
```

### Tipos de Retorno Suportados

```rust
// Valores b√°sicos
Ok(Value::Null)                    // null
Ok(Value::Bool(true))               // boolean
Ok(Value::Number(42.0))             // number
Ok(Value::String("texto".to_string())) // string

// Cole√ß√µes
Ok(Value::Array(vec![Value::String("item1".to_string())]))
Ok(Value::Object(hashmap))

// Erros
Err(DryadError::new(
    "Mensagem de erro".to_string(),
    None,
    ErrorSeverity::Error,
))
```

---

## ‚ö†Ô∏è Sistema de Erros

### Tipos de Severidade

```rust
pub enum ErrorSeverity {
    Warning,    // Avisos - n√£o interrompem execu√ß√£o
    Error,      // Erros - interrompem execu√ß√£o
    Fatal,      // Erros fatais - terminam programa
}
```

### Cria√ß√£o de Erros

```rust
// Erro simples
DryadError::new(
    "Mensagem do erro".to_string(),
    None,
    ErrorSeverity::Error,
)

// Erro com posi√ß√£o (futuro)
DryadError::new(
    "Mensagem do erro".to_string(),
    Some(Position { line: 10, column: 5 }),
    ErrorSeverity::Error,
)
```

### Padr√µes de Mensagens de Erro

```rust
// ‚úÖ Bom: Espec√≠fico e informativo
"console_print: argumento deve ser uma string"
"fs_read_file: arquivo 'dados.txt' n√£o encontrado"
"buffer_create: tamanho deve ser um n√∫mero positivo"

// ‚ùå Ruim: Vago e n√£o informativo
"erro"
"argumento inv√°lido"
"falha na opera√ß√£o"
```

### Tratamento de Erros por Categoria

#### Erros de Valida√ß√£o de Argumentos
```rust
// N√∫mero incorreto de argumentos
if args.len() != expected_count {
    return Err(DryadError::new(
        format!("{}: requer {} argumentos, recebeu {}", 
                function_name, expected_count, args.len()),
        None,
        ErrorSeverity::Error,
    ));
}

// Tipo incorreto
if let Some(Value::String(s)) = args.get(0) {
    // OK
} else {
    return Err(DryadError::new(
        format!("{}: primeiro argumento deve ser uma string", function_name),
        None,
        ErrorSeverity::Error,
    ));
}
```

#### Erros de Sistema
```rust
// Opera√ß√µes de arquivo
match fs::read_to_string(filename) {
    Ok(content) => Ok(Value::String(content)),
    Err(e) => Err(DryadError::new(
        format!("Erro ao ler arquivo '{}': {}", filename, e),
        None,
        ErrorSeverity::Error,
    )),
}

// Opera√ß√µes de rede (futuro)
match reqwest::get(url).await {
    Ok(response) => { /* processar */ },
    Err(e) => Err(DryadError::new(
        format!("Erro de rede: {}", e),
        None,
        ErrorSeverity::Error,
    )),
}
```

---

## üîç Diagn√≥stico de Problemas

### Checklist de Diagn√≥stico

Quando uma fun√ß√£o n√£o funciona, verifique na ordem:

#### 1. Fun√ß√£o Nativa Registrada?
```bash
# Buscar no c√≥digo se a fun√ß√£o est√° registrada
grep -n "native_minha_funcao" src/interpreter/native.rs
```

#### 2. Sintaxe da Biblioteca Correta?
```dryad
// ‚úÖ Correto
public static fn minhaFuncao(param) {
    return native_minha_funcao(param);
}

// ‚ùå Incorreto
public static fun minhaFuncao(param) {  // 'fun' em vez de 'fn'
    return native_minha_funcao(param);
}
```

#### 3. Namespace e Export Corretos?
```dryad
// ‚úÖ Correto
namespace IO {
    export class MinhaClasse {
        public static fn minhaFuncao() { ... }
    }
}

// ‚ùå Incorreto - faltando export
namespace IO {
    class MinhaClasse {  // sem 'export'
        public static fn minhaFuncao() { ... }
    }
}
```

#### 4. Import Correto?
```dryad
// ‚úÖ Correto
using IO.minha_classe;  // nome do arquivo

// ‚ùå Incorreto
using IO.MinhaClasse;   // nome da classe
```

### Testes de Diagn√≥stico

#### Teste 1: Fun√ß√£o Nativa Direta
```dryad
// Testar se a fun√ß√£o nativa existe
let resultado = native_minha_funcao("teste");
```

#### Teste 2: Import da Biblioteca
```dryad
// Testar se o import funciona
using IO.minha_classe;
// Se n√£o der erro, o import est√° OK
```

#### Teste 3: Acesso √† Classe
```dryad
using IO.minha_classe;

// Testar se a classe est√° dispon√≠vel
MinhaClasse.minhaFuncao("teste");
```

---

## üêõ Depura√ß√£o Avan√ßada

### Compila√ß√£o com Debug

```bash
# Compilar em modo debug
cargo build

# Executar com informa√ß√µes de debug
RUST_BACKTRACE=1 ./target/debug/dryad.exe arquivo.dryad
```

### Logs de Depura√ß√£o

Adicione logs tempor√°rios nas fun√ß√µes nativas:

```rust
fn native_minha_funcao(args: &[Value]) -> Result<Value, DryadError> {
    eprintln!("DEBUG: native_minha_funcao chamada com {} argumentos", args.len());
    
    for (i, arg) in args.iter().enumerate() {
        eprintln!("DEBUG: arg[{}] = {:?}", i, arg);
    }
    
    // ... resto da fun√ß√£o
}
```

### Verifica√ß√£o de M√≥dulos Carregados

```dryad
// Verificar se m√≥dulo foi carregado (futuro)
using Core.Debug;

let modulos = Debug.getLoadedModules();
Console.println("M√≥dulos carregados: " + modulos);
```

### Testes Incrementais

```dryad
// test_incremental.dryad
using IO.Console;

Console.println("Passo 1: Import OK");

// Adicionar cada passo gradualmente
using IO.minha_classe;
Console.println("Passo 2: Import classe OK");

MinhaClasse.minhaFuncao("teste");
Console.println("Passo 3: Fun√ß√£o OK");
```

---

## üìê Padr√µes de Implementa√ß√£o

### Estrutura Padr√£o de Biblioteca

```dryad
// lib/IO/exemplo.dryad
// Descri√ß√£o da biblioteca

namespace IO {
    export class Exemplo {
        // Fun√ß√£o principal
        public static fn operacaoPrincipal(param1, param2) {
            return native_exemplo_operacao_principal(param1, param2);
        }
        
        // Fun√ß√£o auxiliar
        public static fn operacaoAuxiliar(param) {
            return native_exemplo_operacao_auxiliar(param);
        }
        
        // Aliases comuns
        public static fn alias(param) {
            return Exemplo.operacaoPrincipal(param, "default");
        }
    }
}
```

### Padr√£o de Implementa√ß√£o Nativa

```rust
// Fun√ß√£o principal
fn native_exemplo_operacao_principal(args: &[Value]) -> Result<Value, DryadError> {
    // Valida√ß√£o de argumentos
    if args.len() < 1 {
        return Err(DryadError::new(
            "exemplo_operacao_principal: requer pelo menos 1 argumento".to_string(),
            None,
            ErrorSeverity::Error,
        ));
    }
    
    // Extra√ß√£o de argumentos
    let param1 = match args.get(0) {
        Some(Value::String(s)) => s,
        _ => return Err(DryadError::new(
            "exemplo_operacao_principal: primeiro argumento deve ser string".to_string(),
            None,
            ErrorSeverity::Error,
        )),
    };
    
    let param2 = args.get(1)
        .and_then(|v| match v {
            Value::String(s) => Some(s.as_str()),
            _ => None,
        })
        .unwrap_or("default");
    
    // L√≥gica da fun√ß√£o
    let resultado = format!("{}-{}", param1, param2);
    
    // Retorno
    Ok(Value::String(resultado))
}

// Fun√ß√£o auxiliar
fn native_exemplo_operacao_auxiliar(args: &[Value]) -> Result<Value, DryadError> {
    // Implementa√ß√£o mais simples
    if let Some(Value::String(param)) = args.get(0) {
        Ok(Value::String(format!("aux-{}", param)))
    } else {
        Err(DryadError::new(
            "exemplo_operacao_auxiliar: argumento deve ser string".to_string(),
            None,
            ErrorSeverity::Error,
        ))
    }
}
```

### Padr√£o de Testes

```dryad
// test_exemplo.dryad
using IO.Console;
using IO.exemplo;

Console.println("=== Teste Biblioteca Exemplo ===");

// Teste 1: Fun√ß√£o principal
let resultado1 = Exemplo.operacaoPrincipal("teste", "valor");
Console.println("Teste 1: " + resultado1);

// Teste 2: Fun√ß√£o auxiliar
let resultado2 = Exemplo.operacaoAuxiliar("teste");
Console.println("Teste 2: " + resultado2);

// Teste 3: Alias
let resultado3 = Exemplo.alias("teste");
Console.println("Teste 3: " + resultado3);

// Teste 4: Tratamento de erro
try {
    Exemplo.operacaoPrincipal();  // Sem argumentos
} catch (e) {
    Console.println("Teste 4: Erro capturado - " + e);
}

Console.println("=== Todos os testes conclu√≠dos ===");
```

---

## ‚úÖ Valida√ß√£o e Testes

### Lista de Verifica√ß√£o Pr√©-Deploy

- [ ] Fun√ß√£o nativa implementada e registrada
- [ ] Valida√ß√£o de argumentos implementada
- [ ] Mensagens de erro informativas
- [ ] Biblioteca Dryad criada com namespace correto
- [ ] Classe exportada corretamente
- [ ] Sintaxe usando `fn` (n√£o `fun`)
- [ ] Teste b√°sico criado e funcionando
- [ ] Teste de erro criado e funcionando
- [ ] Documenta√ß√£o atualizada

### Testes Automatizados (Futuro)

```dryad
// tests/test_exemplo.dryad
using Test.Framework;
using IO.exemplo;

Test.describe("Biblioteca Exemplo", fn() {
    Test.it("deve executar opera√ß√£o principal", fn() {
        let resultado = Exemplo.operacaoPrincipal("a", "b");
        Test.expect(resultado).toBe("a-b");
    });
    
    Test.it("deve tratar erro de argumento", fn() {
        Test.expectError(fn() {
            Exemplo.operacaoPrincipal();
        });
    });
});
```

### M√©tricas de Qualidade

```rust
// Implementar m√©tricas nas fun√ß√µes nativas
fn native_exemplo_com_metricas(args: &[Value]) -> Result<Value, DryadError> {
    let start_time = std::time::Instant::now();
    
    // ... implementa√ß√£o
    
    let duration = start_time.elapsed();
    if duration.as_millis() > 100 {
        eprintln!("WARNING: fun√ß√£o exemplo_com_metricas levou {:?}", duration);
    }
    
    Ok(resultado)
}
```

---

## üö® Problemas Comuns e Solu√ß√µes

### Problema: "Fun√ß√£o n√£o encontrada"

**Causa:** Fun√ß√£o nativa n√£o registrada  
**Solu√ß√£o:**
```rust
// Adicionar em register_io_functions
self.register("native_minha_funcao".to_string(), native_minha_funcao);
```

### Problema: "Classe n√£o encontrada"

**Causa:** Export ou namespace incorreto  
**Solu√ß√£o:**
```dryad
namespace IO {
    export class MinhaClasse {  // 'export' √© obrigat√≥rio
        // ...
    }
}
```

### Problema: "Import falha"

**Causa:** Nome do arquivo incorreto  
**Solu√ß√£o:**
```dryad
using IO.nome_do_arquivo;  // deve ser o nome exato do arquivo .dryad
```

### Problema: "Vari√°vel n√£o definida"

**Causa:** Sintaxe incorreta ou problema de parsing  
**Solu√ß√£o:**
- Verificar uso de `fn` em vez de `fun`
- Verificar fechamento de chaves
- Verificar declara√ß√£o de vari√°veis

### Problema: Fun√ß√£o executa mas retorna erro

**Causa:** Valida√ß√£o de argumentos ou l√≥gica incorreta  
**Solu√ß√£o:**
- Adicionar logs de debug
- Testar fun√ß√£o nativa diretamente
- Verificar tipos de argumentos

---

## üìö Recursos Adicionais

### Comandos √öteis

```bash
# Buscar fun√ß√£o nativa
grep -rn "native_exemplo" src/

# Verificar registros de fun√ß√£o
grep -A 5 -B 5 "register.*exemplo" src/interpreter/native.rs

# Compilar com warnings detalhados
cargo build --verbose

# Verificar sintaxe Dryad
./target/debug/dryad.exe --check arquivo.dryad
```

### Estrutura de Arquivos

```
src/interpreter/
‚îú‚îÄ‚îÄ native.rs          # Implementa√ß√µes de fun√ß√µes nativas
‚îú‚îÄ‚îÄ env.rs             # Defini√ß√µes de tipos Value
‚îú‚îÄ‚îÄ errors.rs          # Sistema de erros
‚îî‚îÄ‚îÄ evaluator.rs       # Avaliador principal

lib/IO/
‚îú‚îÄ‚îÄ console.dryad      # Biblioteca de console
‚îú‚îÄ‚îÄ fs.dryad           # Biblioteca de sistema de arquivos
‚îú‚îÄ‚îÄ buffer.dryad       # Biblioteca de buffer
‚îî‚îÄ‚îÄ novo_modulo.dryad  # Novo m√≥dulo seguindo padr√µes
```

---

**üìù Notas:**
- Esta documenta√ß√£o deve ser atualizada sempre que novos padr√µes forem estabelecidos
- Exemplos devem ser testados antes de serem inclu√≠dos
- Mantenha as mensagens de erro em portugu√™s para consist√™ncia

**üîÑ √öltima atualiza√ß√£o:** 9 de julho de 2025  
**üë• Contribuidores:** Equipe Dryad  
**üìã Status:** Documenta√ß√£o base estabelecida
