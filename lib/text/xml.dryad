// lib/text/xml.dryad
// Módulo para operações XML

namespace Text {
    export class XML {
        
        // ===== FUNÇÕES NATIVAS (necessárias para parsing) =====
        
        // Parse string XML para objeto estruturado
        public static fun parse(xmlString) {
            return native_xml_parse(xmlString);
        }
        
        // Stringify objeto para XML string
        public static fun stringify(xmlObj, indent) {
            if (indent) {
                return native_xml_stringify_pretty(xmlObj, indent);
            } else {
                return native_xml_stringify(xmlObj);
            }
        }
        
        // ===== FUNÇÕES EM DRYAD (utilitários) =====
        
        // Verificar se string é XML válido
        public static fun isValid(xmlString) {
            let result = XML.tryParse(xmlString);
            return result.success;
        }
        
        // Parse com tratamento de erro
        public static fun tryParse(xmlString) {
            // Simula try/catch até ser implementado
            let parsed = native_xml_try_parse(xmlString);
            return parsed;
        }
        
        // Stringify com formatação bonita
        public static fun prettyStringify(xmlObj, indentSize) {
            let indent = indentSize;
            if (!indent) {
                indent = 2;
            }
            return XML.stringify(xmlObj, indent);
        }
        
        // Stringify compacto (sem espaços)
        public static fun compactStringify(xmlObj) {
            return XML.stringify(xmlObj);
        }
        
        // Escapar string para XML
        public static fun escapeText(text) {
            let result = text;
            result = String.replaceAll(result, "&", "&amp;");
            result = String.replaceAll(result, "<", "&lt;");
            result = String.replaceAll(result, ">", "&gt;");
            result = String.replaceAll(result, "\"", "&quot;");
            result = String.replaceAll(result, "'", "&apos;");
            return result;
        }
        
        // Decodificar entidades XML
        public static fun unescapeText(text) {
            let result = text;
            result = String.replaceAll(result, "&lt;", "<");
            result = String.replaceAll(result, "&gt;", ">");
            result = String.replaceAll(result, "&quot;", "\"");
            result = String.replaceAll(result, "&apos;", "'");
            result = String.replaceAll(result, "&amp;", "&");
            return result;
        }
        
        // Criar elemento XML simples
        public static fun createElement(tagName, content, attributes) {
            let result = "<" + tagName;
            
            // Adicionar atributos se fornecidos
            if (attributes) {
                let attrKeys = native_object_keys(attributes);
                let keysLength = native_array_length(attrKeys);
                
                // Substituir por loop para evitar repetição excessiva
                if (keysLength > 0) {
                    let key0 = native_array_get(attrKeys, 0);
                    let value0 = native_object_get(attributes, key0);
                    result = result + " " + key0 + "=\"" + XML.escapeText(value0) + "\"";
                }
                if (keysLength > 1) {
                    let key1 = native_array_get(attrKeys, 1);
                    let value1 = native_object_get(attributes, key1);
                    result = result + " " + key1 + "=\"" + XML.escapeText(value1) + "\"";
                }
                if (keysLength > 2) {
                    let key2 = native_array_get(attrKeys, 2);
                    let value2 = native_object_get(attributes, key2);
                    result = result + " " + key2 + "=\"" + XML.escapeText(value2) + "\"";
                }
                if (keysLength > 3) {
                    let key3 = native_array_get(attrKeys, 3);
                    let value3 = native_object_get(attributes, key3);
                    result = result + " " + key3 + "=\"" + XML.escapeText(value3) + "\"";
                }
                if (keysLength > 4) {
                    let key4 = native_array_get(attrKeys, 4);
                    let value4 = native_object_get(attributes, key4);
                    result = result + " " + key4 + "=\"" + XML.escapeText(value4) + "\"";
                }
            }
            
            if (content && !String.isEmpty(content)) {
                result = result + ">" + XML.escapeText(content) + "</" + tagName + ">";
            } else {
                result = result + " />";
            }
            
            return result;
        }
        
        // Criar elemento XML vazio (self-closing)
        public static fun createEmptyElement(tagName, attributes) {
            return XML.createElement(tagName, "", attributes);
        }
        
        // Extrair texto de elemento XML
        public static fun extractText(xmlElement) {
            return native_xml_extract_text(xmlElement);
        }
        
        // Extrair atributos de elemento XML
        public static fun extractAttributes(xmlElement) {
            return native_xml_extract_attributes(xmlElement);
        }
        
        // Encontrar elemento por tag name
        public static fun findElement(xmlObj, tagName) {
            return native_xml_find_element(xmlObj, tagName);
        }
        
        // Encontrar todos os elementos por tag name
        public static fun findAllElements(xmlObj, tagName) {
            return native_xml_find_all_elements(xmlObj, tagName);
        }
        
        // Obter valor de atributo
        public static fun getAttribute(xmlElement, attributeName) {
            let attributes = XML.extractAttributes(xmlElement);
            return native_object_get(attributes, attributeName);
        }
        
        // Verificar se elemento tem atributo
        public static fun hasAttribute(xmlElement, attributeName) {
            let attributes = XML.extractAttributes(xmlElement);
            return native_object_has_key(attributes, attributeName);
        }
        
        // Converter XML para JSON
        public static fun toJSON(xmlString) {
            let xmlObj = XML.parse(xmlString);
            return native_xml_to_json(xmlObj);
        }
        
        // Converter JSON para XML
        public static fun fromJSON(jsonObj, rootElementName) {
            let rootName = rootElementName;
            if (!rootName) {
                rootName = "root";
            }
            return native_json_to_xml(jsonObj, rootName);
        }
        
        // Validar XML contra schema (básico)
        public static fun validateBasic(xmlString) {
            // Verificações básicas de estrutura
            if (String.isEmpty(xmlString)) {
                return {
                    valid: false,
                    error: "XML string is empty"
                };
            }
            
            // Verificar se tem pelo menos uma tag
            if (!String.contains(xmlString, "<") || !String.contains(xmlString, ">")) {
                return {
                    valid: false,
                    error: "XML string does not contain valid tags"
                };
            }
            
            // Tentar fazer parse
            let parseResult = XML.tryParse(xmlString);
            return {
                valid: parseResult.success,
                error: parseResult.error
            };
        }
        
        // Minificar XML (remover espaços desnecessários)
        public static fun minify(xmlString) {
            return native_xml_minify(xmlString);
        }
        
        // Formatar XML com indentação
        public static fun format(xmlString, indentSize) {
            let indent = indentSize;
            if (!indent) {
                indent = 2;
            }
            
            let parsed = XML.parse(xmlString);
            return XML.prettyStringify(parsed, indent);
        }
        
        // Contar elementos por tag name
        public static fun countElements(xmlObj, tagName) {
            let elements = XML.findAllElements(xmlObj, tagName);
            return native_array_length(elements);
        }
        
        // Obter lista de todas as tag names no XML
        public static fun getTagNames(xmlObj) {
            return native_xml_get_tag_names(xmlObj);
        }
        
        // Verificar se XML está bem formado
        public static fun isWellFormed(xmlString) {
            let validation = XML.validateBasic(xmlString);
            return validation.valid;
        }
        
        // Criar declaração XML
        public static fun createDeclaration(version, encoding, standalone) {
            let decl = "<?xml version=\"";
            decl = decl + (version || "1.0") + "\"";
            
            if (encoding) {
                decl = decl + " encoding=\"" + encoding + "\"";
            }
            
            if (standalone) {
                decl = decl + " standalone=\"" + standalone + "\"";
            }
            
            decl = decl + "?>";
            return decl;
        }
        
        // Criar CDATA section
        public static fun createCDATA(content) {
            return "<![CDATA[" + content + "]]>";
        }
        
        // Verificar se conteúdo é CDATA
        public static fun isCDATA(content) {
            return String.startsWith(content, "<![CDATA[") && 
                   String.endsWith(content, "]]>");
        }
        
        // Extrair conteúdo de CDATA
        public static fun extractCDATA(cdataSection) {
            if (XML.isCDATA(cdataSection)) {
                let start = String.indexOf(cdataSection, "<![CDATA[") + 9;
                let end = String.indexOf(cdataSection, "]]>");
                return String.slice(cdataSection, start, end);
            }
            return cdataSection;
        }
    }
}
